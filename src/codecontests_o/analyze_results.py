"""
Analyze Evaluation Results

Calculates True Positive Rate (TPR) and True Negative Rate (TNR) 
from the results generated by solutions_eval.py.
"""

import os
import json
import argparse
from tqdm import tqdm
from concurrent.futures import ProcessPoolExecutor, as_completed


def _load_json(path):
    with open(path, 'r') as f:
        return json.load(f)


def _remove_file(path):
    os.remove(path)


def _write_text(path, text):
    with open(path, 'w') as f:
        f.write(text)


def _process_result_file(file_path, type):
    """
    Process a single result json file and return stats.
    Returns: {'valid_run': bool, 'accepted_checker': bool, 'accepted_nochecker': bool}
    Returns None if an unexpected error occurs.
    """
    try:
        result = _load_json(file_path)
    except json.JSONDecodeError as e:
        print(f"Error decoding JSON from {os.path.basename(file_path)}: {e}")
        # Delete corrupted file
        try:
            _remove_file(file_path)
        except Exception:
            pass
        return None
    except Exception as e:
        print(f"An error occurred while processing {os.path.basename(file_path)}: {e}")
        return None

    # defensive access
    res = result

    if type == "solution_":
        # Correct solutions should be accepted
        # If accepted=True, it passed.
        accepted_checker = bool(res.get('accepted', False))
        # accepted_nochecker is based on string comparison only
        accepted_nochecker = bool(res.get('accepted_nochecker', False))
        return {'valid_run': True, 'accepted_checker': accepted_checker, 'accepted_nochecker': accepted_nochecker}

    elif type == "incorrect_solution_":
        # Incorrect solutions should be rejected (not accepted)
        # If accepted=False, it's a True Negative.
        accepted_checker = not res.get('accepted', True)
        accepted_nochecker = not res.get('accepted_nochecker', True)
        return {'valid_run': True, 'accepted_checker': accepted_checker, 'accepted_nochecker': accepted_nochecker}

    else:
        print(f"Unknown type: {type} for file {os.path.basename(file_path)}")
        return None


def get_results(result_folder, type="solution_"):
    """
    Sequentially parse files and return (accepted_rate_checker, accepted_rate_nochecker).
    For type="solution_", this is TPR (True Positive Rate).
    For type="incorrect_solution_", this is TNR (True Negative Rate).
    """
    try:
        result_files = [file for file in os.listdir(result_folder) if file.endswith('.json') and file.startswith(type)]
    except FileNotFoundError:
        return -1, -1

    total = len(result_files)
    accepted_checker = 0
    accepted_nochecker = 0

    if total == 0:
        return -1, -1

    for result_file in result_files:
        file_path = os.path.join(result_folder, result_file)
        r = _process_result_file(file_path, type)

        if r is None:
            continue
        
        if r.get('accepted_checker', False):
            accepted_checker += 1
        if r.get('accepted_nochecker', False):
            accepted_nochecker += 1

    accepted_rate_checker = accepted_checker / total
    accepted_rate_nochecker = accepted_nochecker / total

    return accepted_rate_checker, accepted_rate_nochecker


def _process_folder(folder_path):
    """
    Process a single sample folder to calculate TPR and TNR.
    Result is cached in TPR_TNR_checker.txt and TPR_TNR.txt.
    """
    # If TPR_TNR_checker.txt and TPR_TNR.txt exist, skip calculation and read results
    tpr_tnr_checker_path = os.path.join(folder_path, "TPR_TNR_checker.txt")
    tpr_tnr_path = os.path.join(folder_path, "TPR_TNR.txt")
    
    if os.path.exists(tpr_tnr_checker_path) and os.path.exists(tpr_tnr_path):
        # Read checker results
        try:
            with open(tpr_tnr_checker_path, 'r') as f:
                line = f.readline().strip()
                parts = line.replace("TPR:", "").replace("TNR:", "").split(",")
                TPR_checker = float(parts[0].strip())
                TNR_checker = float(parts[1].strip())
        except Exception as e:
            # print(f"Error reading {tpr_tnr_checker_path}: {e}")
            TPR_checker, TNR_checker = -1, -1

        # Read nochecker results
        try:
            with open(tpr_tnr_path, 'r') as f:
                line = f.readline().strip()
                parts = line.replace("TPR:", "").replace("TNR:", "").split(",")
                TPR_nochecker = float(parts[0].strip())
                TNR_nochecker = float(parts[1].strip())
        except Exception as e:
            # print(f"Error reading {tpr_tnr_path}: {e}")
            TPR_nochecker, TNR_nochecker = -1, -1

        return (TPR_checker, TNR_checker, TPR_nochecker, TNR_nochecker)

    # Sequentially calculate TPR and TNR
    TPR_checker, TPR_nochecker = get_results(folder_path, type="solution_")
    TNR_checker, TNR_nochecker = get_results(folder_path, type="incorrect_solution_")
    
    # Write stats to file
    # Write checker results
    text_checker = f"TPR: {TPR_checker}, TNR: {TNR_checker}\n"
    _write_text(tpr_tnr_checker_path, text_checker)

    # Write nochecker results
    text_nochecker = f"TPR: {TPR_nochecker}, TNR: {TNR_nochecker}\n"
    _write_text(tpr_tnr_path, text_nochecker)

    return (TPR_checker, TNR_checker, TPR_nochecker, TNR_nochecker)


def get_TPRs_TNRs(result_folder, max_folder_workers: int = 16):
    """
    Calculate aggregated TPR and TNR across all sample folders.
    
    :param result_folder: Path to the directory containing sample folders
    :param max_folder_workers: Maximum number of parallel workers
    
    Returns tuple of lists and averages.
    """
    try:
        # Filter folders that are directories and not 'log' folder
        result_folders = [
            folder for folder in os.listdir(result_folder) 
            if os.path.isdir(os.path.join(result_folder, folder)) and not folder.endswith('log')
        ]
    except FileNotFoundError:
        print(f"Directory not found: {result_folder}")
        return [], [], 0, 0, [], [], 0, 0, [], [], 0, 0, [], [], 0, 0

    TPRs_checker, TNRs_checker = [], []
    total_TPRs_checker, total_TNRs_checker = [], []
    
    TPRs_nochecker, TNRs_nochecker = [], []
    total_TPRs_nochecker, total_TNRs_nochecker = [], []

    max_folder_workers = min(max_folder_workers, len(result_folders)) if len(result_folders) > 0 else 1

    print(f"Processing {len(result_folders)} sample folders with {max_folder_workers} workers...")

    with ProcessPoolExecutor(max_workers=max_folder_workers) as executor:
        futures = []
        for folder in result_folders:
            folder_path = os.path.join(result_folder, folder)
            futures.append(executor.submit(_process_folder, folder_path))
        
        for future in tqdm(as_completed(futures), total=len(futures), desc=f"Analyzing {os.path.basename(result_folder)}"):
            try:
                (TPR_c, TNR_c, TPR_nc, TNR_nc) = future.result()
            except Exception as e:
                print(f"Error processing folder: {e}")
                continue
            
            # Checker logic
            if TPR_c != -1 and TNR_c != -1:
                TPRs_checker.append(TPR_c)
                TNRs_checker.append(TNR_c)
            if TPR_c != -1:
                total_TPRs_checker.append(TPR_c)
            if TNR_c != -1:
                total_TNRs_checker.append(TNR_c)

            # No checker logic
            if TPR_nc != -1 and TNR_nc != -1:
                TPRs_nochecker.append(TPR_nc)
                TNRs_nochecker.append(TNR_nc)
            if TPR_nc != -1:
                total_TPRs_nochecker.append(TPR_nc)
            if TNR_nc != -1:
                total_TNRs_nochecker.append(TNR_nc)

    # Calculate averages for checker
    avg_TPR_checker = sum(TPRs_checker) / len(TPRs_checker) if TPRs_checker else 0
    avg_TNR_checker = sum(TNRs_checker) / len(TNRs_checker) if TNRs_checker else 0
    total_avg_TPR_checker = sum(total_TPRs_checker) / len(total_TPRs_checker) if total_TPRs_checker else 0
    total_avg_TNR_checker = sum(total_TNRs_checker) / len(total_TNRs_checker) if total_TNRs_checker else 0

    # Calculate averages for no checker
    avg_TPR_nochecker = sum(TPRs_nochecker) / len(TPRs_nochecker) if TPRs_nochecker else 0
    avg_TNR_nochecker = sum(TNRs_nochecker) / len(TNRs_nochecker) if TNRs_nochecker else 0
    total_avg_TPR_nochecker = sum(total_TPRs_nochecker) / len(total_TPRs_nochecker) if total_TPRs_nochecker else 0
    total_avg_TNR_nochecker = sum(total_TNRs_nochecker) / len(total_TNRs_nochecker) if total_TNRs_nochecker else 0

    return (
        TPRs_checker, TNRs_checker, avg_TPR_checker, avg_TNR_checker, 
        total_TPRs_checker, total_TNRs_checker, total_avg_TPR_checker, total_avg_TNR_checker,
        TPRs_nochecker, TNRs_nochecker, avg_TPR_nochecker, avg_TNR_nochecker, 
        total_TPRs_nochecker, total_TNRs_nochecker, total_avg_TPR_nochecker, total_avg_TNR_nochecker
    )


def main():
    parser = argparse.ArgumentParser(description="Analyze results from CodeContests-O evaluation")
    parser.add_argument("--results_dir", type=str, required=True, help="Directory containing evaluation results")
    parser.add_argument("--workers", type=int, default=16, help="Number of parallel workers")
    
    args = parser.parse_args()
    
    results = get_TPRs_TNRs(args.results_dir, max_folder_workers=args.workers)
    
    (
        TPRs_checker, TNRs_checker, avg_TPR_checker, avg_TNR_checker, 
        total_TPRs_checker, total_TNRs_checker, total_avg_TPR_checker, total_avg_TNR_checker,
        TPRs_nochecker, TNRs_nochecker, avg_TPR_nochecker, avg_TNR_nochecker, 
        total_TPRs_nochecker, total_TNRs_nochecker, total_avg_TPR_nochecker, total_avg_TNR_nochecker
    ) = results
    
    print("\n" + "=" * 50)
    print("ANALYSIS RESULTS")
    print("=" * 50)
    
    print("\n[With Checker (Robust)]")
    print(f"Samples with both valid TPR&TNR: {len(TPRs_checker)}")
    print(f"Average TPR (Intersection):      {avg_TPR_checker:.4f}")
    print(f"Average TNR (Intersection):      {avg_TNR_checker:.4f}")
    print("-" * 30)
    print(f"Total TPR samples:               {len(total_TPRs_checker)}")
    print(f"Total Average TPR:               {total_avg_TPR_checker:.4f}")
    print(f"Total TNR samples:               {len(total_TNRs_checker)}")
    print(f"Total Average TNR:               {total_avg_TNR_checker:.4f}")
    
    print("\n[Without Checker (Strict Diff)]")
    print(f"Samples with both valid TPR&TNR: {len(TPRs_nochecker)}")
    print(f"Average TPR (Intersection):      {avg_TPR_nochecker:.4f}")
    print(f"Average TNR (Intersection):      {avg_TNR_nochecker:.4f}")
    print("-" * 30)
    print(f"Total TPR samples:               {len(total_TPRs_nochecker)}")
    print(f"Total Average TPR:               {total_avg_TPR_nochecker:.4f}")
    print(f"Total TNR samples:               {len(total_TNRs_nochecker)}")
    print(f"Total Average TNR:               {total_avg_TNR_nochecker:.4f}")
    print("=" * 50)


if __name__ == "__main__":
    main()
